This section goes into more detail about how you should use Spring Boot. It covers topics such as build systems, auto-configuration and how to run your applications. We also cover some Spring Boot best practices. Although there is nothing particularly special about Spring Boot (it is just another library that you can consume), there are a few recommendations that, when followed, will make your development process just a little easier.
本节将详细介绍如何使用Spring Boot,它涵盖了构建系统、自动配置以及如何运行应用程序等主题。我们还会介绍一些Spring Boot的最佳实践。虽然Spring启动没有什么特别的东西（它只是另一个您可以使用的库），但是如果能遵循一些建议，将使您的开发过程变得简单一点。

If you’re just starting out with Spring Boot, you should probably read the Getting Started guide before diving into this section.
如果您刚刚开始使用Spring引导，那么在进入本节之前您应该阅读入门指南。
13. Build systems 构建系统
我们强烈建议你选择一个构建系统，能够支持依赖管理和方便使用的“库中心”。我们会建议你选择Maven或Gradle。 虽然Spring Boot也可以与其他构建系统（例如Ant）协同工作，但支持度不是特别好。
13.1 Dependency management 依赖管理
Each release of Spring Boot provides a curated list of dependencies it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration as Spring Boot is managing that for you. When you upgrade Spring Boot itself, these dependencies will be upgraded as well in a consistent way.
Spring Boot的每个版本都会提供一个依赖关系列表。实际上，您不需要管理这些依赖项 版本，因为Spring Boot会为您管理。当升级Spring Boot时，这些依赖项也同时会升级。

[Note]
You can still specify a version and override Spring Boot’s recommendations if you feel that’s necessary.
The curated list contains all the spring modules that you can use with Spring Boot as well as a refined list of third party libraries. The list is available as a standard Bills of Materials (spring-boot-dependencies) and additional dedicated support for Maven and Gradle are available as well.
如果觉得有必要的话, 您仍然可以指定一个版本并且覆盖Spring Boot的默认设置。
精心准备的清单包含所有的spring相关的模块和第三方库的清单，你可以在开发Spring boot用到这些模块，你可以通过Maven或者Gradel去使用，因为这个清单本身就是标准的BOM。

[Warning]
Each release of Spring Boot is associated with a base version of the Spring Framework so we highly recommend you to not specify its version on your own.
Spring Boot的每个发布的版本都与Spring框架的原始版本是有关联的，所以我们不建议您自行指定其它的版本。

13.2 Maven
Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults. The parent project provides the following features:
Maven用户可以从spring-boot-starter-parent项目获得必要的默认值，这个项目提供以下的功能：

Java 1.6 as the default compiler level.
Java 1.6 做为默认的编译器版本
UTF-8 source encoding.
UTF-8 编码
A Dependency Management section, allowing you to omit <version> tags for common dependencies, inherited from the spring-boot-dependencies POM.
依赖管理功能，允许您从依赖项中省略<version>标签，直接从spring-boot-dependencies继承。
Sensible resource filtering.
必要的资源过滤
Sensible plugin configuration (exec plugin, surefire, Git commit ID, shade).
必要的插件配置项(exec plugin, surefire, Git commit ID, shade).
Sensible resource filtering for application.properties and application.yml including profile-specific files (e.g. application-foo.properties and application-foo.yml)
针对application.properties 和 application.yml这2个文件做些必要的资源过滤，当然也包括配置相关的特定文件(e.g. application-foo.properties and application-foo.yml)
On the last point: since the default config files accept Spring style placeholders (${…​}) the Maven filtering is changed to use @..@ placeholders (you can override that with a Maven property resource.delimiter).
最后一点，尽管默认的配置文件允许Spring风格的占位符(${…​})，但是在Maven的filtering中，被变成了@..@，（如果你想修改，可以重新设置Maven的resource.delimite属性）

13.2.1 Inheriting the starter parent
继承starter parent

To configure your project to inherit from the spring-boot-starter-parent simply set the parent:
你只要简单设置下parent，就可以让你的项目继承spring-boot-starter-parent的功能

    <!-- Inherit defaults from Spring Boot -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
    </parent>

[Note]
You should only need to specify the Spring Boot version number on this dependency. If you import additional starters, you can safely omit the version number.
你中需要在这里指定Spring Boot的版本号，在引用其它的starters, 就没有必要再指定版本了。
With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to upgrade to another Spring Data release train you’d add the following to your pom.xml.
使用该设置，您还可以通过修改自己项目中的属性来改变依赖项的版本。打个比方，你要升级Spring Data release train的版本，只需把下面的内容添加到pom.xml：

    <properties>
     <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
    </properties>
[Tip]
Check the spring-boot-dependencies pom for a list of supported properties.
检查spring-boot-dependencies pom能支持的所有属性

13.2.2 Using Spring Boot without the parent POM

Not everyone likes inheriting from the spring-boot-starter-parent POM. You may have your own corporate standard parent that you need to use, or you may just prefer to explicitly declare all your Maven configuration.
并不是每个人都喜欢直接从spring-boot-starter-parent POM继承， 有时候，你需要一个符合自己公司需求的parent, 你会更倾向声明独有的Maven配置
If you don’t want to use the spring-boot-starter-parent, you can still keep the benefit of the dependency management (but not the plugin management) by using a scope=import dependency:
就算你不想用spring-boot-starter-parent，但通过scope=import，你仍然可以享受依赖管理能提供的便利(其中不包括插件管理)

    <dependencyManagement>
         <dependencies>
            <dependency>
                <!-- Import dependency management from Spring Boot -->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>1.5.2.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    That setup does not allow you to override individual dependencies using a property as explained above. To achieve the same result, you’d need to add an entry in the dependencyManagement of your project before the spring-boot-dependencies entry. For instance, to upgrade to another Spring Data release train you’d add the following to your pom.xml.
    
    <dependencyManagement>
        <dependencies>
            <!-- Override Spring Data release train provided by Spring Boot -->
            <dependency>
                <groupId>org.springframework.data</groupId>
                <artifactId>spring-data-releasetrain</artifactId>
                <version>Fowler-SR2</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>1.5.2.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
[Note]
In the example above, we specify a BOM but any dependency type can be overridden that way.
在上面的例子中，我们指定了一个BOM，但是对于依赖，我们可以用这种方式重写。
13.2.3 Changing the Java version
修改Java版本

The spring-boot-starter-parent chooses fairly conservative Java compatibility. If you want to follow our recommendation and use a later Java version you can add a java.version property:
spring-boot-starter-parent考虑到兼容性， 选择较为保守的java版本。如果你想使用最新的java版本，可以添加一个java.version属性：
    <properties>
        <java.version>1.8</java.version>
    </properties>
13.2.4 Using the Spring Boot Maven plugin
使用Spring Boot的Maven插件
Spring Boot includes a Maven plugin that can package the project as an executable jar. Add the plugin to your <plugins> section if you want to use it:
Spring Boot可以包含Maven插件，用这个插件就可以将项目打包成一个可以单独执行的jar文件，如果你想使用这个功能，只要将插件声明，放到<plugins>块中

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
[Note]
If you use the Spring Boot starter parent pom, you only need to add the plugin, there is no need for to configure it unless you want to change the settings defined in the parent.
如果您使用的是Spring Boot的父POM，那么只需添加插件，而不需要对它进行额外的配置，除非您要更改父类中定义的设置。

13.3 Gradle
Gradle users can directly import ‘starters’ in their dependencies section. Unlike Maven, there is no “super parent” to import to share some configuration.
Gradle用户可以直接在dependencies中导入‘starters’，跟Maven不一样，没有“super parent”已经包含了一些共用的设置。
    repositories {
        jcenter()
    }
    
    dependencies {
        compile("org.springframework.boot:spring-boot-starter-web:1.5.2.RELEASE")
    }
The spring-boot-gradle-plugin is also available and provides tasks to create executable jars and run projects from source. 
It also provides dependency management that, among other capabilities, allows you to omit the version number for any dependencies that are managed by Spring Boot:
spring-boot-gradle-plugin 也可以引用插件，来生成可执行的jar文件。
Gradel也提供依赖管理功能，对于Spring boot内置支持的依赖，允许你不提供版本号.

    plugins {
        id 'org.springframework.boot' version '1.5.2.RELEASE'
        id 'java'
    }


    repositories {
        jcenter()
    }
    
    dependencies {
        compile("org.springframework.boot:spring-boot-starter-web")
        testCompile("org.springframework.boot:spring-boot-starter-test")
    }
13.4 Ant
It is possible to build a Spring Boot project using Apache Ant+Ivy. The spring-boot-antlib “AntLib” module is also available to help Ant create executable jars.
用Apache Ant+Ivy， 我们也可以来构建Spring Boot 项目， spring-boot-antlib 有个“AntLib” 模块，可以帮助创建可执行的jar文件.

To declare dependencies a typical ivy.xml file will look something like this:
比如像下面，就是一个典型的ivy.xml，其中包含了依赖：
    <ivy-module version="2.0">
        <info organisation="org.springframework.boot" module="spring-boot-sample-ant" />
        <configurations>
            <conf name="compile" description="everything needed to compile this module" />
            <conf name="runtime" extends="compile" description="everything needed to run this module" />
        </configurations>
        <dependencies>
            <dependency org="org.springframework.boot" name="spring-boot-starter"
                rev="${spring-boot.version}" conf="compile" />
        </dependencies>
    </ivy-module>
    
A typical build.xml will look like this:
build.xml可以参考下面：

    <project
        xmlns:ivy="antlib:org.apache.ivy.ant"
        xmlns:spring-boot="antlib:org.springframework.boot.ant"
        name="myapp" default="build">
    
        <property name="spring-boot.version" value="1.3.0.BUILD-SNAPSHOT" />
    
        <target name="resolve" description="--> retrieve dependencies with ivy">
            <ivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" />
        </target>
    
        <target name="classpaths" depends="resolve">
            <path id="compile.classpath">
                <fileset dir="lib/compile" includes="*.jar" />
            </path>
        </target>
    
        <target name="init" depends="classpaths">
            <mkdir dir="build/classes" />
        </target>
    
        <target name="compile" depends="init" description="compile">
            <javac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" />
        </target>
    
        <target name="build" depends="compile">
            <spring-boot:exejar destfile="build/myapp.jar" classes="build/classes">
                <spring-boot:lib>
                    <fileset dir="lib/runtime" />
                </spring-boot:lib>
            </spring-boot:exejar>
        </target>
    </project>
[Tip]
See the Section 84.10, “Build an executable archive from Ant without using spring-boot-antlib” “How-to” if you don’t want to use the spring-boot-antlib module.

13.5 Starters
Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.

The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies.

What’s in a name

All official starters follow a similar naming pattern; spring-boot-starter-*, where * is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs allow you to search dependencies by name. For example, with the appropriate Eclipse or STS plugin installed, you can simply hit ctrl-space in the POM editor and type “spring-boot-starter” for a complete list.

As explained in the Creating your own starter section, third party starters should not start with spring-boot as it is reserved for official Spring Boot artifacts. A third-party starter for acme will be typically named acme-spring-boot-starter.

The following application starters are provided by Spring Boot under the org.springframework.boot group:

Table 13.1. Spring Boot application starters

Name	Description	Pom
spring-boot-starter-thymeleaf
Starter for building MVC web applications using Thymeleaf views
Pom
spring-boot-starter-data-couchbase
Starter for using Couchbase document-oriented database and Spring Data Couchbase
Pom
spring-boot-starter-artemis
Starter for JMS messaging using Apache Artemis
Pom
spring-boot-starter-web-services
Starter for using Spring Web Services
Pom
spring-boot-starter-mail
Starter for using Java Mail and Spring Framework’s email sending support
Pom
spring-boot-starter-data-redis
Starter for using Redis key-value data store with Spring Data Redis and the Jedis client
Pom
spring-boot-starter-web
Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container
Pom
spring-boot-starter-data-gemfire
Starter for using GemFire distributed data store and Spring Data GemFire
Pom
spring-boot-starter-activemq
Starter for JMS messaging using Apache ActiveMQ
Pom
spring-boot-starter-data-elasticsearch
Starter for using Elasticsearch search and analytics engine and Spring Data Elasticsearch
Pom
spring-boot-starter-integration
Starter for using Spring Integration
Pom
spring-boot-starter-test
Starter for testing Spring Boot applications with libraries including JUnit, Hamcrest and Mockito
Pom
spring-boot-starter-jdbc
Starter for using JDBC with the Tomcat JDBC connection pool
Pom
spring-boot-starter-mobile
Starter for building web applications using Spring Mobile
Pom
spring-boot-starter-validation
Starter for using Java Bean Validation with Hibernate Validator
Pom
spring-boot-starter-hateoas
Starter for building hypermedia-based RESTful web application with Spring MVC and Spring HATEOAS
Pom
spring-boot-starter-jersey
Starter for building RESTful web applications using JAX-RS and Jersey. An alternative to spring-boot-starter-web
Pom
spring-boot-starter-data-neo4j
Starter for using Neo4j graph database and Spring Data Neo4j
Pom
spring-boot-starter-data-ldap
Starter for using Spring Data LDAP
Pom
spring-boot-starter-websocket
Starter for building WebSocket applications using Spring Framework’s WebSocket support
Pom
spring-boot-starter-aop
Starter for aspect-oriented programming with Spring AOP and AspectJ
Pom
spring-boot-starter-amqp
Starter for using Spring AMQP and Rabbit MQ
Pom
spring-boot-starter-data-cassandra
Starter for using Cassandra distributed database and Spring Data Cassandra
Pom
spring-boot-starter-social-facebook
Starter for using Spring Social Facebook
Pom
spring-boot-starter-jta-atomikos
Starter for JTA transactions using Atomikos
Pom
spring-boot-starter-security
Starter for using Spring Security
Pom
spring-boot-starter-mustache
Starter for building MVC web applications using Mustache views
Pom
spring-boot-starter-data-jpa
Starter for using Spring Data JPA with Hibernate
Pom
spring-boot-starter
Core starter, including auto-configuration support, logging and YAML
Pom
spring-boot-starter-groovy-templates
Starter for building MVC web applications using Groovy Templates views
Pom
spring-boot-starter-freemarker
Starter for building MVC web applications using FreeMarker views
Pom
spring-boot-starter-batch
Starter for using Spring Batch
Pom
spring-boot-starter-social-linkedin
Stater for using Spring Social LinkedIn
Pom
spring-boot-starter-cache
Starter for using Spring Framework’s caching support
Pom
spring-boot-starter-data-solr
Starter for using the Apache Solr search platform with Spring Data Solr
Pom
spring-boot-starter-data-mongodb
Starter for using MongoDB document-oriented database and Spring Data MongoDB
Pom
spring-boot-starter-jooq
Starter for using jOOQ to access SQL databases. An alternative to spring-boot-starter-data-jpa or spring-boot-starter-jdbc
Pom
spring-boot-starter-jta-narayana
Spring Boot Narayana JTA Starter
Pom
spring-boot-starter-cloud-connectors
Starter for using Spring Cloud Connectors which simplifies connecting to services in cloud platforms like Cloud Foundry and Heroku
Pom
spring-boot-starter-jta-bitronix
Starter for JTA transactions using Bitronix
Pom
spring-boot-starter-social-twitter
Starter for using Spring Social Twitter
Pom
spring-boot-starter-data-rest
Starter for exposing Spring Data repositories over REST using Spring Data REST
Pom

In addition to the application starters, the following starters can be used to add production ready features:

Table 13.2. Spring Boot production starters

Name	Description	Pom
spring-boot-starter-actuator
Starter for using Spring Boot’s Actuator which provides production ready features to help you monitor and manage your application
Pom
spring-boot-starter-remote-shell
Starter for using the CRaSH remote shell to monitor and manage your application over SSH. Deprecated since 1.5
Pom

Finally, Spring Boot also includes some starters that can be used if you want to exclude or swap specific technical facets:

Table 13.3. Spring Boot technical starters

Name	Description	Pom
spring-boot-starter-undertow
Starter for using Undertow as the embedded servlet container. An alternative to spring-boot-starter-tomcat
Pom
spring-boot-starter-jetty
Starter for using Jetty as the embedded servlet container. An alternative to spring-boot-starter-tomcat
Pom
spring-boot-starter-logging
Starter for logging using Logback. Default logging starter
Pom
spring-boot-starter-tomcat
Starter for using Tomcat as the embedded servlet container. Default servlet container starter used by spring-boot-starter-web
Pom
spring-boot-starter-log4j2
Starter for using Log4j2 for logging. An alternative to spring-boot-starter-logging
Pom

[Tip]
For a list of additional community contributed starters, see the README file in the spring-boot-starters module on GitHub.
14. Structuring your code
Spring Boot does not require any specific code layout to work, however, there are some best practices that help.

14.1 Using the “default” package
When a class doesn’t include a package declaration it is considered to be in the “default package”. The use of the “default package” is generally discouraged, and should be avoided. It can cause particular problems for Spring Boot applications that use @ComponentScan, @EntityScan or @SpringBootApplication annotations, since every class from every jar, will be read.

[Tip]
We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, com.example.project).
14.2 Locating the main application class
We generally recommend that you locate your main application class in a root package above other classes. The @EnableAutoConfiguration annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the @EnableAutoConfiguration annotated class will be used to search for @Entity items.

Using a root package also allows the @ComponentScan annotation to be used without needing to specify a basePackage attribute. You can also use the @SpringBootApplication annotation if your main class is in the root package.

Here is a typical layout:

com
 +- example
     +- myproject
         +- Application.java
         |
         +- domain
         |   +- Customer.java
         |   +- CustomerRepository.java
         |
         +- service
         |   +- CustomerService.java
         |
         +- web
             +- CustomerController.java
The Application.java file would declare the main method, along with the basic @Configuration.

package com.example.myproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
15. Configuration classes
Spring Boot favors Java-based configuration. Although it is possible to call SpringApplication.run() with an XML source, we generally recommend that your primary source is a @Configuration class. Usually the class that defines the main method is also a good candidate as the primary @Configuration.

[Tip]
Many Spring configuration examples have been published on the Internet that use XML configuration. Always try to use the equivalent Java-based configuration if possible. Searching for enable* annotations can be a good starting point.
15.1 Importing additional configuration classes
You don’t need to put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes.

15.2 Importing XML configuration
If you absolutely must use XML based configuration, we recommend that you still start with a @Configuration class. You can then use an additional @ImportResource annotation to load XML configuration files.

16. Auto-configuration
Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, If HSQLDB is on your classpath, and you have not manually configured any database connection beans, then we will auto-configure an in-memory database.

You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes.

[Tip]
You should only ever add one @EnableAutoConfiguration annotation. We generally recommend that you add it to your primary @Configuration class.
16.1 Gradually replacing auto-configuration
Auto-configuration is noninvasive, at any point you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support will back away.

If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. This will enable debug logs for a selection of core loggers and log an auto-configuration report to the console.

16.2 Disabling specific auto-configuration
If you find that specific auto-configure classes are being applied that you don’t want, you can use the exclude attribute of @EnableAutoConfiguration to disable them.

import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}
If the class is not on the classpath, you can use the excludeName attribute of the annotation and specify the fully qualified name instead. Finally, you can also control the list of auto-configuration classes to exclude via the spring.autoconfigure.exclude property.

[Tip]
You can define exclusions both at the annotation level and using the property.
17. Spring Beans and dependency injection
You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. For simplicity, we often find that using @ComponentScan to find your beans, in combination with @Autowired constructor injection works well.

If you structure your code as suggested above (locating your application class in a root package), you can add @ComponentScan without any arguments. All of your application components (@Component, @Service, @Repository, @Controller etc.) will be automatically registered as Spring Beans.

Here is an example @Service Bean that uses constructor injection to obtain a required RiskAssessor bean.

package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
And if a bean has one constructor, you can omit the @Autowired.

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
[Tip]
Notice how using constructor injection allows the riskAssessor field to be marked as final, indicating that it cannot be subsequently changed.
18. Using the @SpringBootApplication annotation
Many Spring Boot developers always have their main class annotated with @Configuration, @EnableAutoConfiguration and @ComponentScan. Since these annotations are so frequently used together (especially if you follow the best practices above), Spring Boot provides a convenient @SpringBootApplication alternative.

The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration and @ComponentScan with their default attributes:

package com.example.myproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
[Note]
@SpringBootApplication also provides aliases to customize the attributes of @EnableAutoConfiguration and @ComponentScan.
19. Running your application
One of the biggest advantages of packaging your application as jar and using an embedded HTTP server is that you can run your application as you would any other. Debugging Spring Boot applications is also easy; you don’t need any special IDE plugins or extensions.

[Note]
This section only covers jar based packaging, If you choose to package your application as a war file you should refer to your server and IDE documentation.
19.1 Running from an IDE
You can run a Spring Boot application from your IDE as a simple Java application, however, first you will need to import your project. Import steps will vary depending on your IDE and build system. Most IDEs can import Maven projects directly, for example Eclipse users can select Import…​ → Existing Maven Projects from the File menu.

If you can’t directly import your project into your IDE, you may be able to generate IDE metadata using a build plugin. Maven includes plugins for Eclipse and IDEA; Gradle offers plugins for various IDEs.

[Tip]
If you accidentally run a web application twice you will see a “Port already in use” error. STS users can use the Relaunch button rather than Run to ensure that any existing instance is closed.
19.2 Running as a packaged application
If you use the Spring Boot Maven or Gradle plugins to create an executable jar you can run your application using java -jar. For example:

$ java -jar target/myproject-0.0.1-SNAPSHOT.jar
It is also possible to run a packaged application with remote debugging support enabled. This allows you to attach a debugger to your packaged application:

$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myproject-0.0.1-SNAPSHOT.jar
19.3 Using the Maven plugin
The Spring Boot Maven plugin includes a run goal which can be used to quickly compile and run your application. Applications run in an exploded form just like in your IDE.

$ mvn spring-boot:run
You might also want to use the useful operating system environment variable:

$ export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=128M
19.4 Using the Gradle plugin
The Spring Boot Gradle plugin also includes a bootRun task which can be used to run your application in an exploded form. The bootRun task is added whenever you import the spring-boot-gradle-plugin:

$ gradle bootRun
You might also want to use this useful operating system environment variable:

$ export JAVA_OPTS=-Xmx1024m -XX:MaxPermSize=128M
19.5 Hot swapping
Since Spring Boot applications are just plain Java applications, JVM hot-swapping should work out of the box. JVM hot swapping is somewhat limited with the bytecode that it can replace, for a more complete solution JRebel or the Spring Loaded project can be used. The spring-boot-devtools module also includes support for quick application restarts.

See the Chapter 20, Developer tools section below and the Hot swapping “How-to” for details.

20. Developer tools
Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The spring-boot-devtools module can be included in any project to provide additional development-time features. To include devtools support, simply add the module dependency to your build:

Maven. 

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
Gradle. 

dependencies {
    compile("org.springframework.boot:spring-boot-devtools")
}
[Note]
Developer tools are automatically disabled when running a fully packaged application. If your application is launched using java -jar or if it’s started using a special classloader, then it is considered a “production application”. Flagging the dependency as optional is a best practice that prevents devtools from being transitively applied to other modules using your project. Gradle does not support optional dependencies out-of-the-box so you may want to have a look to the propdeps-plugin in the meantime.
[Tip]
repackaged archives do not contain devtools by default. If you want to use certain remote devtools feature, you’ll need to disable the excludeDevtools build property to include it. The property is supported with both the Maven and Gradle plugins.
20.1 Property defaults
Several of the libraries supported by Spring Boot use caches to improve performance. For example, template engines will cache compiled templates to avoid repeatedly parsing template files. Also, Spring MVC can add HTTP caching headers to responses when serving static resources.

Whilst caching is very beneficial in production, it can be counter productive during development, preventing you from seeing the changes you just made in your application. For this reason, spring-boot-devtools will disable those caching options by default.

Cache options are usually configured by settings in your application.properties file. For example, Thymeleaf offers the spring.thymeleaf.cache property. Rather than needing to set these properties manually, the spring-boot-devtools module will automatically apply sensible development-time configuration.

[Tip]
For a complete list of the properties that are applied see DevToolsPropertyDefaultsPostProcessor.
20.2 Automatic restart
Applications that use spring-boot-devtools will automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a folder will be monitored for changes. Note that certain resources such as static assets and view templates do not need to restart the application.

Triggering a restart

As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using. In Eclipse, saving a modified file will cause the classpath to be updated and trigger a restart. In IntelliJ IDEA, building the project (Build → Make Project) will have the same effect.

[Note]
You can also start your application via the supported build plugins (i.e. Maven and Gradle) as long as forking is enabled since DevTools need an isolated application classloader to operate properly. Gradle and Maven do that by default when they detect DevTools on the classpath.
[Tip]
Automatic restart works very well when used with LiveReload. See below for details. If you use JRebel automatic restarts will be disabled in favor of dynamic class reloading. Other devtools features (such as LiveReload and property overrides) can still be used.
[Note]
DevTools relies on the application context’s shutdown hook to close it during a restart. It will not work correctly if you have disabled the shutdown hook ( SpringApplication.setRegisterShutdownHook(false)).
[Note]
When deciding if an entry on the classpath should trigger a restart when it changes, DevTools automatically ignores projects named spring-boot, spring-boot-devtools, spring-boot-autoconfigure, spring-boot-actuator, and spring-boot-starter.
Restart vs Reload

The restart technology provided by Spring Boot works by using two classloaders. Classes that don’t change (for example, those from third-party jars) are loaded into a base classloader. Classes that you’re actively developing are loaded into a restart classloader. When the application is restarted, the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts” since the base classloader is already available and populated.

If you find that restarts aren’t quick enough for your applications, or you encounter classloading issues, you could consider reloading technologies such as JRebel from ZeroTurnaround. These work by rewriting classes as they are loaded to make them more amenable to reloading. Spring Loaded provides another option, however it doesn’t support as many frameworks and it isn’t commercially supported.

20.2.1 Excluding resources

Certain resources don’t necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can just be edited in-place. By default changing resources in /META-INF/maven, /META-INF/resources ,/resources ,/static ,/public or /templates will not trigger a restart but will trigger a live reload. If you want to customize these exclusions you can use the spring.devtools.restart.exclude property. For example, to exclude only /static and /public you would set the following:

spring.devtools.restart.exclude=static/**,public/**
[Tip]
if you want to keep those defaults and add additional exclusions, use the spring.devtools.restart.additional-exclude property instead.
20.2.2 Watching additional paths

You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath. To do so, use the spring.devtools.restart.additional-paths property to configure additional paths to watch for changes. You can use the spring.devtools.restart.exclude property described above to control whether changes beneath the additional paths will trigger a full restart or just a live reload.

20.2.3 Disabling restart

If you don’t want to use the restart feature you can disable it using the spring.devtools.restart.enabled property. In most cases you can set this in your application.properties (this will still initialize the restart classloader but it won’t watch for file changes).

If you need to completely disable restart support, for example, because it doesn’t work with a specific library, you need to set a System property before calling SpringApplication.run(…​). For example:

public static void main(String[] args) {
    System.setProperty("spring.devtools.restart.enabled", "false");
    SpringApplication.run(MyApp.class, args);
}
20.2.4 Using a trigger file

If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times. To do this you can use a “trigger file”, which is a special file that must be modified when you want to actually trigger a restart check. Changing the file only triggers the check and the restart will only occur if Devtools has detected it has to do something. The trigger file could be updated manually, or via an IDE plugin.

To use a trigger file use the spring.devtools.restart.trigger-file property.

[Tip]
You might want to set spring.devtools.restart.trigger-file as a global setting so that all your projects behave in the same way.
20.2.5 Customizing the restart classloader

As described in the Restart vs Reload section above, restart functionality is implemented by using two classloaders. For most applications this approach works well, however, sometimes it can cause classloading issues.

By default, any open project in your IDE will be loaded using the “restart” classloader, and any regular .jar file will be loaded using the “base” classloader. If you work on a multi-module project, and not each module is imported into your IDE, you may need to customize things. To do this you can create a META-INF/spring-devtools.properties file.

The spring-devtools.properties file can contain restart.exclude. and restart.include. prefixed properties. The include elements are items that should be pulled up into the “restart” classloader, and the exclude elements are items that should be pushed down into the “base” classloader. The value of the property is a regex pattern that will be applied to the classpath.

For example:

restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar
[Note]
All property keys must be unique. As long as a property starts with restart.include. or restart.exclude. it will be considered.
[Tip]
All META-INF/spring-devtools.properties from the classpath will be loaded. You can package files inside your project, or in the libraries that the project consumes.
20.2.6 Known limitations

Restart functionality does not work well with objects that are deserialized using a standard ObjectInputStream. If you need to deserialize data, you may need to use Spring’s ConfigurableObjectInputStream in combination with Thread.currentThread().getContextClassLoader().

Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you will need to request a fix with the original authors.

20.3 LiveReload
The spring-boot-devtools module includes an embedded LiveReload server that can be used to trigger a browser refresh when a resource is changed. LiveReload browser extensions are freely available for Chrome, Firefox and Safari from livereload.com.

If you don’t want to start the LiveReload server when your application runs you can set the spring.devtools.livereload.enabled property to false.

[Note]
You can only run one LiveReload server at a time. Before starting your application, ensure that no other LiveReload servers are running. If you start multiple applications from your IDE, only the first will have LiveReload support.
20.4 Global settings
You can configure global devtools settings by adding a file named .spring-boot-devtools.properties to your $HOME folder (note that the filename starts with “.”). Any properties added to this file will apply to all Spring Boot applications on your machine that use devtools. For example, to configure restart to always use a trigger file, you would add the following:

~/.spring-boot-devtools.properties. 

spring.devtools.reload.trigger-file=.reloadtrigger
20.5 Remote applications
The Spring Boot developer tools are not just limited to local development. You can also use several features when running applications remotely. Remote support is opt-in, to enable it you need to make sure that devtools is included in the repackaged archive:

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludeDevtools>false</excludeDevtools>
            </configuration>
        </plugin>
    </plugins>
</build>
Then you need to set a spring.devtools.remote.secret property, for example:

spring.devtools.remote.secret=mysecret
[Warning]
Enabling spring-boot-devtools on a remote application is a security risk. You should never enable support on a production deployment.
Remote devtools support is provided in two parts; there is a server side endpoint that accepts connections, and a client application that you run in your IDE. The server component is automatically enabled when the spring.devtools.remote.secret property is set. The client component must be launched manually.

20.5.1 Running the remote client application

The remote client application is designed to be run from within your IDE. You need to run org.springframework.boot.devtools.RemoteSpringApplication using the same classpath as the remote project that you’re connecting to. The non-option argument passed to the application should be the remote URL that you are connecting to.

For example, if you are using Eclipse or STS, and you have a project named my-app that you’ve deployed to Cloud Foundry, you would do the following:

Select Run Configurations…​ from the Run menu.
Create a new Java Application “launch configuration”.
Browse for the my-app project.
Use org.springframework.boot.devtools.RemoteSpringApplication as the main class.
Add https://myapp.cfapps.io to the Program arguments (or whatever your remote URL is).
A running remote client will look like this:

  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 1.5.2.RELEASE

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
[Note]
Because the remote client is using the same classpath as the real application it can directly read application properties. This is how the spring.devtools.remote.secret property is read and passed to the server for authentication.
[Tip]
It’s always advisable to use https:// as the connection protocol so that traffic is encrypted and passwords cannot be intercepted.
[Tip]
If you need to use a proxy to access the remote application, configure the spring.devtools.remote.proxy.host and spring.devtools.remote.proxy.port properties.
20.5.2 Remote update

The remote client will monitor your application classpath for changes in the same way as the local restart. Any updated resource will be pushed to the remote application and (if required) trigger a restart. This can be quite helpful if you are iterating on a feature that uses a cloud service that you don’t have locally. Generally remote updates and restarts are much quicker than a full rebuild and deploy cycle.

[Note]
Files are only monitored when the remote client is running. If you change a file before starting the remote client, it won’t be pushed to the remote server.
20.5.3 Remote debug tunnel

Java remote debugging is useful when diagnosing issues on a remote application. Unfortunately, it’s not always possible to enable remote debugging when your application is deployed outside of your data center. Remote debugging can also be tricky to setup if you are using a container based technology such as Docker.

To help work around these limitations, devtools supports tunneling of remote debug traffic over HTTP. The remote client provides a local server on port 8000 that you can attach a remote debugger to. Once a connection is established, debug traffic is sent over HTTP to the remote application. You can use the spring.devtools.remote.debug.local-port property if you want to use a different port.

You’ll need to ensure that your remote application is started with remote debugging enabled. Often this can be achieved by configuring JAVA_OPTS. For example, with Cloud Foundry you can add the following to your manifest.yml:

---
    env:
        JAVA_OPTS: "-Xdebug -Xrunjdwp:server=y,transport=dt_socket,suspend=n"
[Tip]
Notice that you don’t need to pass an address=NNNN option to -Xrunjdwp. If omitted Java will simply pick a random free port.
[Note]
Debugging a remote service over the Internet can be slow and you might need to increase timeouts in your IDE. For example, in Eclipse you can select Java → Debug from Preferences…​ and change the Debugger timeout (ms) to a more suitable value (60000 works well in most situations).
[Warning]
When using the remote debug tunnel with IntelliJ IDEA, all breakpoints must be configured to suspend the thread rather than the VM. By default, breakpoints in IntelliJ IDEA suspend the entire VM rather than only suspending the thread that hit the breakpoint. This has the unwanted side-effect of suspending the thread that manages the remote debug tunnel, causing your debugging session to freeze. When using the remote debug tunnel with IntelliJ IDEA, all breakpoints should be configured to suspend the thread rather than the VM. Please see IDEA-165769 for further details.
21. Packaging your application for production
Executable jars can be used for production deployment. As they are self-contained, they are also ideally suited for cloud-based deployment.

For additional “production ready” features, such as health, auditing and metric REST or JMX end-points; consider adding spring-boot-actuator. See Part V, “Spring Boot Actuator: Production-ready features” for details.

22. What to read next
You should now have good understanding of how you can use Spring Boot along with some best practices that you should follow. You can now go on to learn about specific Spring Boot features in depth, or you could skip ahead and read about the “production ready” aspects of Spring Boot.